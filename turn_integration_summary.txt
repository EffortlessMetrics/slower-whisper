================================================================================
TURN, SPEAKER_STATS, AND ENRICHMENT INTEGRATION ANALYSIS
================================================================================

OVERVIEW
--------
The project has a 4-stage enrichment pipeline:
  1. Diarization (assign speakers to segments)
  2. Turn Building (group segments by speaker)
  3. Turn Enrichment (add metadata to turns)
  4. Speaker Stats (aggregate per-speaker metrics)

Key Finding: Turns flow as DICTS through the pipeline, NOT as Turn dataclass
instances, despite type annotations suggesting otherwise.


DATA FLOW SUMMARY
-----------------

Stage 1: Diarization (diarization.py)
  Input:  Audio file + transcript.segments (no speaker info)
  Output: transcript.speakers[], segment.speaker = {"id", "confidence"}

  Key Function: assign_speakers(transcript, speaker_turns)
    - Mutates segments in place
    - Creates transcript.speakers list

Stage 2: Turn Building (turns.py)
  Input:  transcript.segments (with speaker labels)
  Output: transcript.turns = [dict, dict, ...]

  Key Function: build_turns(transcript)
    - Groups contiguous segments by speaker
    - Calls _finalize_turn() → returns DICT (not Turn class!)
    - Type annotation says list[Turn | dict] but code only creates dicts

Stage 3A: Turn Enrichment (turns_enrich.py)
  Input:  transcript.turns (basic dicts)
  Output: transcript.turns (same dicts with added "metadata" key)

  Key Function: enrich_turns_metadata(transcript)
    - Reads turns via turn_to_dict(turn, copy=True)
    - Computes metadata: question_count, interruption_started_here, etc
    - Creates NEW dict with metadata attached
    - Replaces transcript.turns with enriched version

Stage 3B: Speaker Stats (speaker_stats.py)
  Input:  transcript.turns (with metadata) + transcript.segments
  Output: transcript.speaker_stats = [dict, dict, ...]

  Key Function: compute_speaker_stats(transcript)
    - Groups turns/segments by speaker
    - Uses turn_to_dict(t) to read turns
    - Counts interruptions from turn["metadata"]["interruption_started_here"]
    - Creates SpeakerStats dataclass → converts to dict via .to_dict()

Stage 4: JSON Output (writers.py)
  Input:  transcript (with turns + speaker_stats)
  Output: JSON file

  Key Function: write_json(transcript, path)
    - Calls _to_dict(turn) for each turn (lenient converter)
    - Calls _to_dict(stat) for each stat
    - Serializes to JSON


TURN CONVERSION HELPERS
-----------------------

Five different conversion mechanisms exist:

1. turn_to_dict() [turn_helpers.py:11-43] — PRIMARY
   - Location: turn_helpers.py
   - Type: STRICT (raises TypeError on failure)
   - Used by: turns_enrich.py, speaker_stats.py, test_turn_helpers.py
   - Behavior: dict → as-is | object with to_dict() → calls it | dataclass → asdict()

2. _normalize_turns() [chunking.py:51-81] — SEPARATE IMPLEMENTATION
   - Location: chunking.py
   - Type: HYBRID (manual field extraction)
   - Does NOT use turn_to_dict()!
   - Handles: both dataclass and dict by checking hasattr/isinstance

3. _to_dict() [writers.py:12-37] — LENIENT
   - Location: writers.py
   - Type: LENIENT (returns original on failure)
   - Used by: write_json()
   - Behavior: dict → as-is | to_dict() → calls it | dataclass → asdict() | other → unchanged

4. _as_dict() [llm_utils.py:39-53] — STRICT (DIFFERENT FROM turn_to_dict!)
   - Location: llm_utils.py
   - Type: STRICT (raises TypeError on failure)
   - Used by: render_conversation_compact(), to_turn_view()
   - Behavior: dict → as-is | to_dict() → calls it | dataclass → asdict() | other → raise

5. exporters.py inline [lines 44-60] — MANUAL REIMPLEMENTATION
   - Location: exporters.py
   - Type: MANUAL (if/elif/else chain)
   - Does NOT use turn_to_dict()!
   - Reimplements logic locally


turn_to_dict() USAGE STATISTICS
--------------------------------

Total references: 53 (including tests)

Files using turn_to_dict():
  - turns_enrich.py (2 calls): lines 66, 93
  - speaker_stats.py (3 calls): lines 99, 108, 111
  - test_turn_helpers.py (53 references in tests)

Files NOT using turn_to_dict() but converting turns:
  - exporters.py (line 45): reimplements logic
  - llm_utils.py (lines 317, 408): uses _as_dict() instead
  - writers.py (line 94): uses _to_dict() instead
  - chunking.py (line 51): uses _normalize_turns() instead


KEY INCONSISTENCIES
--------------------

Inconsistency 1: TYPE ANNOTATION vs REALITY
  Location: turns.py:103-104
  Problem: Type says list[Turn | dict] but code only creates dicts
  Impact: Type checker accepts Turn instances that never exist at runtime

Inconsistency 2: MULTIPLE TURN-TO-DICT IMPLEMENTATIONS
  Problem: 5 different ways to convert turns in codebase
  Impact: Code duplication, inconsistent error handling, maintenance burden

Inconsistency 3: MUTATION DURING ENRICHMENT
  Location: turns_enrich.py:116
  Problem: Creates NEW dicts instead of modifying in place
  Impact: Uses # type: ignore to suppress type errors

Inconsistency 4: TURN FIELD EXTRACTION PATTERNS
  Problem: chunking.py duplicates field extraction without using turn_to_dict()
  Impact: Fragile code that checks for both attribute and dict access

Inconsistency 5: METADATA DEPENDENCY NOT VALIDATED
  Location: speaker_stats.py:109
  Problem: Assumes turn.metadata exists, but build_turns() doesn't create it
  Impact: If turn enrichment skipped, speaker stats incomplete/broken


DEPENDENCY CHAIN
----------------

build_turns()
    ↓ produces: list[dict] with keys {id, speaker_id, start, end, segment_ids, text}
    ↓
enrich_turns_metadata()
    ├─ DEPENDS ON: turns existing
    ├─ REQUIRES: turn_to_dict() to read turns
    └─ PRODUCES: same dicts + "metadata" key added
        ↓
compute_speaker_stats()
    ├─ DEPENDS ON: turns with metadata
    ├─ REQUIRES: turn_to_dict() to read turns
    ├─ READS: turn["metadata"]["interruption_started_here"]
    └─ PRODUCES: speaker_stats list

NOTE: If turn enrichment skipped, speaker_stats will have 0 interruptions!


TYPING ISSUES
-------------

Issue 1: Union Type Not Realized (turns.py:103)
  - Type promises: list[Turn | dict[str, Any]]
  - Reality: only dicts are ever created
  - Fix: Change to list[dict[str, Any]]

Issue 2: Type Ignore Suppression (turns_enrich.py:116)
  - transcript.turns = enriched_turns  # type: ignore[assignment]
  - Indicates type mismatch that should be resolved

Issue 3: Missing Literal Types (exporters.py, chunking.py)
  - unit: str = "segments"  # should be Literal["segments", "turns"]

Issue 4: turn_to_dict() Not Exported
  - Defined in turn_helpers.py but not in __init__.py
  - Other modules reinvent the wheel


CRITICAL FINDINGS
------------------

1. DICTS NOT CLASSES: Turns flow as dicts, not Turn dataclass instances
   - Despite models.py defining Turn class
   - Type system overpromises what exists

2. MULTIPLE CONVERTERS: 5 different turn-to-dict implementations
   - Only 2 use turn_to_dict()
   - Others reimimplement or use different functions
   - No single source of truth

3. OPTIONAL METADATA: Turn metadata is optional
   - build_turns() doesn't create it
   - enrich_turns_metadata() adds it
   - compute_speaker_stats() needs it
   - No validation that order is correct

4. HIDDEN DEPENDENCIES: speaker_stats needs turn metadata
   - If someone calls compute_speaker_stats() without enrich_turns_metadata()
   - Result will be silently incomplete (zero interruptions)
   - No error or warning raised


RECOMMENDATIONS SUMMARY
-----------------------

Short Term (v1.1):
  1. Fix type annotations to match reality (turns as dicts)
  2. Centralize turn_to_dict() as canonical converter
  3. Remove # type: ignore comments once types are correct

Medium Term (v1.2):
  1. Consider creating Turn instances instead of dicts
  2. Make metadata required, not optional
  3. Add validation that enrichment stages run in order

Long Term (v1.3):
  1. Use TypedDict for turn structure
  2. Add schema validation
  3. Better error messages for missing metadata


FILES ANALYZED
--------------

Core modules:
  - transcription/turns.py
  - transcription/turns_enrich.py
  - transcription/speaker_stats.py
  - transcription/turn_helpers.py
  - transcription/diarization.py
  - transcription/models.py
  - transcription/writers.py
  - transcription/llm_utils.py
  - transcription/exporters.py
  - transcription/chunking.py
  - transcription/api.py

Test files:
  - tests/test_turn_helpers.py
  - tests/test_turns_enrich.py
  - tests/test_speaker_analytics_pipeline.py
  - tests/test_turns.py

Total lines analyzed: ~5000+
